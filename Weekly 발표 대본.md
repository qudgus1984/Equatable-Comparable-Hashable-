1.



안녕하세요! Weekly 발표를 진행하게 된 이병현이라고 합니다.

제가 발표할 주제는 Protocol 3대장, E / h / c에 대해 발표하려고 합니다.

처음엔 간단한 주제라고 생각하였고, 가볍게 접근했다가 된통 당한 주제였습니다…



그래서 부제로 생각보다 좀 어렵다…? 라고 지었습니다



2.



목차가 어떻게 진행되는지 살펴보겠습니다.
첫 번째로, 발표 주제를 선정하게 된 계기가 무엇인지 간단하게 소개하고, 
왜 E / H / C이 프로토콜로 이루어져 있는지 생각해보는 시간을 갖고,
E H H C에 대해 발표하고 마무리하겠습니다.



3.



주제를 선정한 이유는 먼저 수업 시간에 배웠던 부분을 제외하고 다뤄보자! 라고 생각했습니다.
수업에서 가르쳐 준 부분은 잭님의 완벽한 설명과 다들 열심히 과제를 하면서 깊게 공부하셨을 거라고 생각해
언급을 많이 하지 않은 부분에 대해 발표해보자! 라는 생각을 했던 것 같아요

두번째로는 중요한 개념에 대해 다뤄보자! 라는 생각을 했습니다.
중요한 개념에 대해 다루면서 다른 사람들이 이 개념에 대해 물어볼 때 정말 자세하게 알려주자라는 생각이었습니다.

마지막으로, 어…? 이거 어디서 들어봤는데…? 하는 것들이 개발 공부를 하면서 많이 겪었던 것 같습니다.
그래서 이렇게 들어만 본것들을 정리하고 제 것으로 만드는게 필요하다 생각했었습니다.



4.



이러한 기준으로 발표 주제를 정하는 것이 생각보다 어렵더라구요. 
아시는분은 아실거 같은 그 제르시님의 깃허브에서 면접 질문지 정리 글을 허락받고 블로그에 포스팅 했던 적이 있는데
그 글을 보고 내리다가
어… 어?
Hashable…? Equatable…?
그래…! 이거야…!
하고 주제를 선정했습니다.



5.



왜 Equatable / Hashable / Comparable은 프로토콜로 이루어져 있을까요?
저희 기본 자료형의 타입이 무엇으로 이루어져 있는지 아시나요??
Struct로 이루어져 있습니다!!
그리고 E/H/C은 기본 자료형들의 기본적인 기능들이기 때문에 Protocol로 만들고 채택한 것이죠.
이는 Pop에 대한 개념과 비슷하다고 생각하는데, 발표주제와는 방향성이 다르니 넘어가도록 하겠습니다.



6.



그럼 이제부터 본격적으로 시작해보도록 할게요
Equatable에 대해 먼저 알아보도록 하겠습니다.
Equatable의 정의에 대해 먼저 알아보고, 각 열거형 / 구조체/ 클래스에 대해 직접 Equatable을 채택해보겠습니다.
클래스에 이쿼터블을 채택하면 나타나는 현상에 대해서도 봐보도록 할게요.



7.



이쿼터블이란 등호 연산자를 사용할 수 있도록 만들어주는 역할이라고 합니다.
저희가 이렇게 Int타입인 JackAge 와 Int타입인 HueAge에 대해 비교해볼 수 있는 이유는, Int타입이 바로 Hashable을 
채택하고 있기 때문이고, Hashable은 Equatable을 채택하고 있기 때문에 가능한 것입니다.
8.

열거형 / 구조체 / 클래스는 Equatable이 채택되어있지 않기 때문에 비교가 불가능합니다.
Equatable을 채택한다면 비교를 할 수 있다! 이렇게 봐주시면 될 것 같아요

9. Playground로 직접 보면서 확인해보도록 하겠습니다.

Equatable 실습파일

연관값이 없는 Enum

먼저, 열거형은 연관값이 존재하냐, 존재하지 않냐의 차이로 Equatable의 채택 유무가 결정됩니다.

만약 연관값이 없다면, 같은지/다른지 동일성은 판별 가능하다는 논리로

Equatable을 채택하지 않아도 case끼리는 동일성을 비교할 수 있게 됩니다.

연관값이 있는 Enum

연관값이 있는 열거형의 경우, Equatable을 채택해주어야만 비교가 가능 합니다. 

이때에는 연관값까지 모두 같아야 == 이 true로 반환됩니다.


이제 구조체에 Equatable을 채택해보겠습니다.

구조체는 Equatable만 채택해주면, 각 저장 속성이 전부 같으면 같다라고 기본 값으로 제공을 해줍니다.

만약, 여기서 저장 속성 중 하나만 같아도 같은 인스턴스로 판단하게 끔 해주고 싶다면?!

예를 들면, 여기서의 잭님은 23살이시지만, 다른 메타버스의 잭님은 나이가 46살이라면?!

그런 경우를 대비해 이름만 같아도 같은 인스턴스로 판단하게 끔 위와같이 직접 비교연산자를 정의할 수 있습니다.

이제 클레스에 Equatable을 채택해보도록 할게요

구조체와 똑같이 Equatable을 채택해보도록 할게요!

왜 오류가 날까요?
클래스와 구조체의 차이에 대해 생각해보아야 합니다.
구조체와 클래스는 값을 저장하는 방식이 다릅니다.
구조체는 값을 스택 영역에 저장하고, 클래스는 값을 Heap의 영역에 저장하고, stack에는 메모리 주소값을 저장하죠.
그리고 class는 heap의 값을 비교할 수 있는 항등 연산자가 존재합니다.
위 Jack과 Hue를 보면, 같은 값을 저장함에도 불구하고 다른 메모리 공간에 저장되어 있기 때문에
항등연산자를 비교해보면 false가 나오게 됩니다.
하지만 메타버스 잭은 잭 자체를 담았기 때문에 같은 메모리 공간을 가르키므로 같다고 나오게 되는 것이죠
그래서 항등연산자가 class에는 존재하기 때문에, equatable을 채택하기 위해선 같다의 정의를
개발자가 직접 내려주어야 하며, 기본값으로 제공할 수 없는 것입니다.


12.

Equatable에 대해 알아보았고, 이번에는 Hashable에 대해 알아보도록 할게요.
Hashable의 정의가 무엇인지 알아보고, Hash Table에 대해 이해해본 다음, 구조체 열거형 클래스에서 hashable을 채택해보는 실습을 가져보도록 하겠습니다.

도큐먼트를 보면, 해시어블은 정수 hash값을 hash를 통해 생성할 수 있는 타입이라고 정의합니다.
이를 더 직관적으로 말하면 해시 함수의 인풋값으로 사용가능한 타입이다 라고 할 수 있겠네요.
음...? 하나도 모르겠는데...? 하시면 정상입니다.
왜냐하면 Hash Table에 대해 알 지 못하면 Hashable은 알 수 없는 개념이기 때문입니다.
그럼 해시테이블에 대해 알아보도록 할게요

13.

해시테이블이란, 키 벨류 형식으로 데이터를 저장하는 자료구조 중 하나입니다.
키...벨류..? 많이 들어보지 않으셨나요?!
바로 스위프트에서 딕셔너리가 이러한 해시 테이블 형식으로 이루어져 있답니다!!
그리고 맨 처음 equatable 정의할 때 보았던 것처럼 hashable은 equatable을 채택하였죠.
그리고 해시 테이블은 빠른 검색속도를 제공하는데, 그 이유는 내부적으로 배열을 사용해서 데이터를 저장하기 때문이라고 합니다.
해시 테이블은 내부적으로 배열을 사용한다! 딕셔너리가 해시테이블 형식이다! 해시어블은 이쿼터블을 채택하였다! 라는 키워드만 가지고 같이
해시테이블을 이해해보도록 할게요

14.

위 그림을 보면, 잭, 휴, 나 라는 키 값이 있고, 벨류 값으로 살려주세요, 병현님 할 수 있으시잖아요, 지금 램테이블 구조가 올바른 구조일까요 로 해시테이블 안에 배열 형태로 만들어져 있습니다.
엇 근데 저희는 배열의 값에 접근할 때 어떻게 접근하죠? 인덱스로 접근하지 않나요?
그래서 이렇게 해시 테이블 인덱스가 존재합니다.
그리고 잭이라는 키를 넣으면, 병현님할수이짜나요라는 벨류에 바로 접근하는 것이 아니라, 인덱스 1로
접근하게 되고, 이 인덱스 1 순서에 있는 벨류 값을 가져다 보여주는 것이죠.
이를 정리해서 보면,
Key값을 넣으면, 배열의 고유한 index에 접근하게 됌
고유한 index로 Value값에 접근
이렇게 되는것이죠.

15.

이때 Key값을 넣었을 때 고유한 index로 값을 반환해주는 것이 바로 Hash Function입니다!!
이 해시함수가 키 값을 넣으면 내부적으로 처리해서 고유한 인덱스를 반환해주고, 그 인덱스를 통해 배열의 값에 접근하는 것이죠.
그리고 해싱은 이러한 과정을 통틀어 해싱한다! 라고 표현합니다.
이때 해시함수로 사용되는 알고리즘이 바로 저번에 휴님이 말씀하신 깃 토큰 방식의 sha-1, sha-256 등등 저희가 들어본 해싱 기술들이라고 합니다!
이제 해시어블의, 해시함수의 인풋 값으로 사용 가능한 타입이라고 정의햇었습니다.
이제는 의미가 이해가 되시지 않나요?!
따라서 해시함수의 인풋값으로 사용가능하기 위해서 해시어블은 같은지 판단하기 위해 equatable을 상속받는
것이죠. 같은 값이면 이에 따른 같은 인덱스가 나와야 하니까요.
그래서 해시어블하다라고 한다면 고유하다라는 의미로도 사용되는 것입니다.
그래도 개발친구가 물어본다면, 멋있게 해시함수의 인풋값으로 사용가능한게 해시어블한것이다! 라고 말해주면
좀 있어보이지 않을까요?
아까 해시테이블은 빠른 검색속도를 자랑한다고 했는데, 이에 대해서도 왜 해시테이블이 빠른지 알아보도록 할게요

16.

먼저, 단순히 배열에서 값을 찾는 방법은 메서드마다 다르긴 하지만 보통 선형 검색 (리뉴어 서치)방식을 사용합니다.
선형 검색이란 이처럼 처음부터 용석님이 나올때까지 하나하나 찾아가는 것이죠.
이렇게 처음부터 하나씩 하나씩 찾으니 시간 복잡도의 개념으로는 항상 max값을 기준으로 판단하므로
빅오 표기법으로는 O(n) 이라고 합니다.

17.

하지만 해시테이블을 이용한 방식은, 해싱을 통해 인덱스 값이 바로 반환되고, 이 반환값으로 바로 배열의 특정 값에 접근하기 때문에 시간 복잡도의 개념으로 빅오 표기법 O(1)이라고 합니다.
이래서 딕셔너리가 빠를 수밖에 없고, 저장, 검색, 삭제 등 속도가 중요한 탐색기능을 사용할 때 많이
활용된다고 합니다.

18.
이제 다시 해시어블에 대한 정의를 보게되면, 이제는 이해가 되시지 않나요?!

19.
이제 다시 플레이그라운드를 통해 해시어블을 열거형 구조체 클래스에서 채택하고 사용해보도록 하겠습니다.

플레이그라운드

열거형

아까 이쿼터블때 나누었던 것처럼, 연관값의 유무에 따라 해시어블의 채택의 유무가 나뉩니다.

이때 굳이 Hashable을 채택하지 않아도 각 case가 Hashable 하기 때문에 Set의 원소로 들어갈 수 있게 됩니다.

이렇게 연관값이 있는 열거형은 해시어블을 채택해주면 각 저장속성의 값에 따라 Set에 저장하게 됩니다.

이번엔 구조체를 보겠습니다. 기본으로 채택해줬을 경우 hash(into: )함수가 기본값으로 제공해주기 때문에

굳이 함수를 재정의하지 않는 이상 모든 저장속성의 값을 기준으로 판단해주게 됩니다.

그래서 해쉬어블하기 때문에 matabusJack을 Set의 값에 넣어도 같은 값으로 판단하기 때문에 값이 저장되지 않는 것입니다.

만약 이름으로만 hashable한지 판단하고 싶으면 직접 hash와 ==를 정의해주면 됩니다.

하지만 특별한 경우가 아닌 이상 저장 속성의 값이 전부 같을 때를 기준으로 판단하는 것이 일반적입니다.

클래스에서 해시어블을 판단해보도록 하겠습니다.

이전에 클래스는 이쿼터블을 판단할 수 없다고 말씀드렸죠?

해시어블은 이쿼터블을 상속받는 함수이기 때문에, 해쉬어블을 클래스에 채택해주기 위해서는

이쿼터블과 해시어블을 둘 다 판단해주어야 합니다.

20.
이제 마지막으로, comparable에 대해 알아보도록 할게요
컴퍼러블의 정의에 대해 알아보고, 열거형, 구조체, 클래스에서 어떻게 채택하는지 알아보도록 하겠습니다.

21.
도큐먼트를 보면, 이쿼터블처럼 컴페어러블은 대소 비교를 할 수 있는 연산자를 사용할 수 있도록 만들어주는 역할을 해줍니다.
그래서 같은지도 판단해야하므로 이쿼터블을 해쉬어블처럼 채택한 구조입니다.

22.

기본 자료형에서는 불타입을 제외하고는 전부 컴페어러블을 채택하였기 때문에 비교가 가능합니다.
음...? 하신분들 계시나요?!
저도 아무생각없이 적다가 음? String도 대소비교가 돼?? 문자열 길이비교가 아니라 값크기 비교인데?!
네!! 됩니다!!

23.

그러면 어떠한 기준으로 비교를 하냐
바로 유니코드 값으로 비교를 한다고 합니다!
잭님과 휴님을 비교해보니, 역시? 잭님이 크다고 나오네요...
역시 실세입니다...

이제 진짜진짜 마지막으로 comparable을 실습해보고 마무리해보도록 할게요

컴페어러블은 연관값의 여부로 비교하는 것이 아니라, 원시값의 여부로 비교를 합니다.

저도 방금까지 모르고 있었는데, 원시값을 채택해주지 않으면 기본값이 인트형이라고 말씀해주셔서 더 

명확하게 설명할 수 있을 것 같네요.

때문에 case에 대해 비교하는 것이 가능해집니다. 그래서 원시값이 없는 열거형은 comparable을 채택해주기만 하더라도 케이스끼리 비교가 가능합니다.

원시값의 기본값으로 잭님이 0번, 휴님이 1번 이렇게 원시값울 기준으로 비교하기 때문에 대소비교는 가능하다 라는 논리입니다.

하지만 원시값을 개발자가 직접 지정해 준다면, 개발자가 직접 대응되는 값을 제공하기 때문에 정렬 방식또한 구현해야합니다.

근데 스위프트는 정말 친절한게, less then 하나만 구현해도 나머지를 알아서 구현해줍니다. 정말 친절한 언어죠?!

덕분에 많은 노가다할뻔한 것을 줄였습니다.. 고맙다 스위프트

이번엔 구조체에 컴페어러블을 구현해보겠습니다.

이전에 했던 것과 마찬가지로 comparable을 채택해주면 자동으로 구현이... 안되네요?

사실 천천히 생각해보면 당연한 결과입니다. 어떤 기준으로 대소를 비교할 것인지 모르기 때문이죠.

나이를 기준으로 비교를 한다고 가정하면

이렇게 직접 대소에 대한 정의를 내려주어야 합니다.

이제 정말 마지막이네요.

클래스에 컴페이러블을 구현해보도록 할게요.

애는... 이쿼터블도 구현이 안되어있기 때문에, 이쿼터블 메서드, 대소비교 메서드를 전부 다 구현해주어야 합니다.

이번에도 나이를 기준으로 구분해 줘 볼게요

이렇게 비교가 잘 되는 것을 볼 수 있습니다.

25.

이렇게 이쿼터블, 해쉬어블, 컴페어러블에대해 알아보았습니다.

간단한 줄로만 알았던 내용들이 생각보다 pop, hashtable, 해싱, 시간복잡도, 구조체, 클래스의 차이 등 다양한 cs / 문법적 지식을 공부하면서 여러가지 개념들을 복합적으로 이해하는 경험을 해 본 것 같아 매우 만족했던 발표 주제였던 것 같습니다.

내부적으로 들어가면 들어갈 수록 많은 어려운 내용들이 숨어있다는 것을 느꼈고, 깊게 공부하는것이 얼마나 중요한 지 다시금 느꼈던 것 같네요.

해시 테이블이나 이쿼터블, 해시어블, 컴페어러블에 대해 궁금한 점이 있거나 자료가 필요하시면 디엠주시면 제가 아는데까지 찾아보고 말씀드리도록 할게요!

지금까지 발표를 들어주셔서 감사합니다@


